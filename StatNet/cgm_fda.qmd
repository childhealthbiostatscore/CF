---
title: "Functional Analysis of CGM Data"
author: "Tim Vigers"
format: 
  revealjs:
    scrollable: true
editor: visual
---

## The Question

-   Do nighttime glucose patterns differ between controls (HC), CF with normal glucose tolerance (CFNGT), CF with abnormal glucose tolerance (CFAGT), and people with CF related diabetes (CFRD)?

```{r}
#| include: false
# Libraries
library(arsenal)
library(tidyverse)
library(lubridate)
library(cgmanalysis)
library(refund)
library(refund.shiny)
# Data import
sleep = read.csv("~/Dropbox/Work/Vigers/CF/Christine Chan/CGM and FDA/Data_Raw/sleep.csv",
                 na.strings = "")
# Get bedtime and wake times
sleep = sleep %>% 
  mutate(Day.1.End = Day.2.Date,Day.2.End = Day.3.Date,Day.3.End = Day.4.Date,
         Day.4.End = Day.5.Date,Day.5.End = Day.6.Date,Day.6.End = Day.7.Date) %>%
  select(Subject.ID:Average.BMI.Z.score,
         matches("Day\\.\\d\\.Date"),
         matches("Day\\.\\d\\.Date"),
         matches("Day\\.\\d\\.Bed.Time"),
         matches("Day\\.\\d\\.Get.Up.Time"))
sleep = sleep %>% 
  pivot_longer(Day.1.Date:Day.7.Get.Up.Time,
               names_to = c("Day",".value"),names_pattern = "Day\\.(.)\\.(.*)") %>%
  filter(!is.na(Bed.Time) & !is.na(Get.Up.Time) & Day < 7) %>%
  mutate(Night.Start = ymd_hm(paste(Date,Bed.Time)),
         Night.End = ymd_hm(paste(Date,Get.Up.Time))+days(1)) %>%
  select(Subject.ID:Average.BMI.Z.score,Day,Night.Start,Night.End)
sleep$Subject.ID = sub("--1","",sleep$Subject.ID)
# Add a day for those going to sleep between 12am - 6am
sleep$Night.Start[hour(sleep$Night.Start) %in% 0:6] = 
  sleep$Night.Start[hour(sleep$Night.Start) %in% 0:6] + days(1)
# Shorter group names
sleep$Combined.Group.Category = 
  factor(sleep$Combined.Group.Category,
         levels = c("Healthy Control",
                    "Cystic Fibrosis Normal Glucose Tolerant",
                    "Cystic Fibrosis Abnormal Glycemia",
                    "Cystic Fibrosis Related Diabetes"),
         labels = c("HC","CF-NGT","CF-AGT","CFRD"),ordered = T)
# HC not on insulin
sleep$CF.Insulin.Use[sleep$Combined.Group.Category == "HC"]="No"
# CGMs
# cleandata("~/Dropbox/Work/Vigers/CF/Christine Chan/CGM and FDA/Data_Raw/CGM",
#           "~/Dropbox/Work/Vigers/CF/Christine Chan/CGM and FDA/Data_Clean/CGM",
#           removegaps = F)
cgms = list.files("~/Dropbox/Work/Vigers/CF/Christine Chan/CGM and FDA/Data_Clean/CGM",
                  full.names = T)
names(cgms) = unlist(lapply(cgms, function(f){
  df = read.csv(f)
  id = strsplit(basename(f)," ")[[1]][1]
  return(id)
}))
# For each actiwatch, pull out the relevant vector of CGM values
sleep = sleep[sleep$Subject.ID %in% names(cgms),]
vecs = apply(sleep,1,function(r){
  # Pull info
  id = as.character(r["Subject.ID"])
  start = ymd_hms(as.character(r["Night.Start"]))
  end = ymd_hms(as.character(r["Night.End"]))
  # Find CGM file
  df = read.csv(cgms[id])
  df$timestamp = round_date(ymd_hms(df$timestamp),"5 minutes")
  # Get the time between sensors
  interval = table(round(diff(df$timestamp)/60))
  interval = names(interval)[which.max(interval)]
  # Put glucose values on time grid, pull glucose values
  times = round_date(seq(start,end,by = paste(interval,"min")),"5 minutes")
  glucs = data.frame(cbind(times,df$sensorglucose[match(times,df$timestamp)]))
  glucs = glucs[,2]
  # Grid sequence for functional data
  arg = seq(0,1,length.out = length(glucs))
  return(list(glucs,arg))
})
# Pull out glucose values and sequences separately
glucs = sapply(vecs,"[[",1)
args = sapply(vecs,"[[",2)
# Find those where all glucose values are missing
keep = sapply(glucs, function(g){!all(is.na(g)) & !is.na(var(g,na.rm = T))})
# Make functional object, add to demographic info
fda_df = sleep %>% select(Subject.ID:Average.BMI.Z.score)
fda_df = fda_df[keep,]
fda_df$Glucose = tfd(glucs[keep],args[keep],interpolate=T)
```

## Our dataset {.smaller}

```{r results='asis'}
demo = fda_df %>%
  select(Subject.ID:Average.BMI.Z.score) %>% 
  group_by(Subject.ID) %>% 
  summarise(Age = Age[1],Gender = Gender[1],Race = Race.Ethnicity[1],
            Insulin = CF.Insulin.Use[1],`BMI Z Score`= Average.BMI.Z.score[1],
            `Days of Data` = n(),Group = Combined.Group.Category[1])
t1 = 
  tableby(Group~Age+Gender+Race+Insulin+`BMI Z Score`+`Days of Data`,
             data = demo)
summary(t1)
```

## Plot

```{r}
fda_df %>% 
  ggplot() + 
  geom_spaghetti(aes(tf = Glucose),alpha=0.2) +
  scale_color_discrete(name="") + theme_bw() +
  facet_wrap(~Combined.Group.Category)
```

## Basis Function

In general, the Fourier basis is the usual choice for periodic functions.

\cite{ramsayFunctionalDataAnalysis2009}

```{r}
basisobj = create.fourier.basis(rangeval=c(0, 1))
plot(basisobj)
```

```{r cache=TRUE}
fpca = rfr_fpca(Y = "Glucose", data = fda_df)
fda_df %>%
  modelr::add_predictions(fpca, var = "glucose_fits") %>%
  ggplot(aes(y = glucose_fits)) +
  geom_spaghetti() +
  geom_spaghetti(aes(y = Glucose), color = "blue", alpha = .2)
```

```{r}
ys = apply(sleep,1,function(r){
  # Pull info
  id = as.character(r["Subject.ID"])
  start = ymd_hms(as.character(r["Night.Start"]))
  end = ymd_hms(as.character(r["Night.End"]))
  # Find CGM file
  df = read.csv(cgms[id])
  id = paste(as.character(r["Subject.ID"]),as.character(r["Day"]),sep = "_")
  df$timestamp = round_date(ymd_hms(df$timestamp),"5 minutes")
  # Get the time between sensors
  interval = table(round(diff(df$timestamp)/60))
  interval = names(interval)[which.max(interval)]
  # Put glucose values on time grid
  times = round_date(seq(start,end,by = paste(interval,"min")),"5 minutes")
  glucs = df$sensorglucose[match(times,df$timestamp)]
  y = data.frame(".obs"=rep(id,length(glucs)),
                 ".index"=seq(0,1,length.out=length(glucs)),
                 ".value" = glucs)
  return(y)
})
# Find those where all glucose values are missing
# keep = sapply(ys, function(y){!all(is.na(y$.value)) & !is.na(var(y$.value,na.rm = T))})
ydata = do.call(rbind,ys)
colnames(ydata)[1] = ".id"
fit = fpca.sc(ydata=na.omit(ydata[ydata$.id %in% names(table(ydata$.id)[1:10]),]),
              var = TRUE, simul = FALSE)
```

```{r}
library(fdapace)
library(fastDummies)
vecs = apply(sleep,1,function(r){
  # Pull info
  id = as.character(r["Subject.ID"])
  start = ymd_hms(as.character(r["Night.Start"]))
  end = ymd_hms(as.character(r["Night.End"]))
  # Find CGM file
  df = read.csv(cgms[id])
  df$timestamp = round_date(ymd_hms(df$timestamp),"5 minutes")
  # Get the time between sensors
  interval = table(round(diff(df$timestamp)/60))
  interval = names(interval)[which.max(interval)]
  # Put glucose values on time grid, pull glucose values
  times = round_date(seq(start,end,by = paste(interval,"min")),"5 minutes")
  glucs = data.frame(cbind(times,df$sensorglucose[match(times,df$timestamp)]))
  glucs = glucs[,2]
  # Grid sequence for functional data
  arg = seq(0,length(glucs))
  return(list(glucs,arg))
})
ylist = sapply(vecs,"[[",1)
tlist = sapply(vecs,"[[",2)
keep = sapply(ylist, function(g){!all(is.na(g)) & !is.na(var(g,na.rm = T))})
X = sleep %>% select(Subject.ID:Average.BMI.Z.score)
X = X[keep,]
X = dummy_cols(X[,"Combined.Group.Category"],remove_selected_columns=T,remove_first_dummy=T)
FPCAobj <- FPCA(Ly=ylist[keep], Lt=tlist[keep],list(plot = TRUE))
VCAM(Lt=tlist[1:10], Ly=ylist[1:10],X[1:10])
```

## Questions for the Group

-   What is the best way to pick the order of basis functions, etc.?
-   Currently I'm forcing the glucose measures to be on the interval \[0,1\], which means that the period for the Fourier basis is "nighttime." Since those with shorter sleep periods will have fewer observations, I think this means that
